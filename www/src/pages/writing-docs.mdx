---
title: Writing Documentation
---

# Writing Documentation

Docpocalypse generates documentation by aggregating infomation from multiple places and using multiple tools, some
autogenerated and some handwritten.

## Comments and types

Docpocalypse will generate basic API documentation from JSDoc (or TSDoc) comment
blocks, as well as prop-types (in the case of components), or TypeScript type annotations.
Annotate your code and it will automatically be collected under the API heading
for each element.

### With PropTypes

If you use React prop-types to type check your components, those will be collected
as well as accompanying comments.

````jsx
const propTypes = {
  /**
   * The visual style of the Button
   *
   * @default "primary"
   */
  variant: PropTypes.oneOf(['primary', 'danger', 'warning', 'info'];

  /** Show a spinner **/
  busy: PropTypes.boolean;
}

/**
 * A cool Button component
 */
function Button({ variant = 'primary', busy, children }) {
  return (
    <button className={cn(btn, `btn-${variant}`)}>
      {busy && <Spinner />}
      {children}
    </button>
  );
}

Button.propTypes = propTypes


/**
 * Returns the app configuration for an env
 *
 * ```
 *   const config = useAppConfig({ env: 'dev' })
 * ```
 * @param {Object} options
 * @param {'dev' | 'prod' | 'staging'} options.env
 */
function useAppConfig({ env }) {
  return useContext(AppContext)
}

````

### With TypeScript

TypeScript provides the most comprehensive API data and can also be enhanced with
TSDoc style comments and markdown.

````tsx static
interface Props {
  /** The visual style of the Button **/
  variant: 'primary' | 'danger' | 'warning' | 'info';

  /** Show a spinner **/
  busy?: boolean;

  children?: React.ReactNode;
}

/**
 * A cool Button component
 *
 * ```
 * <Button variant="danger">
 * ```
 */
function Button({ variant = 'primary', busy, children }: Props) {
  return (
    <button className={cn(btn, `btn-${variant}`)}>
      {busy && <Spinner />}
      {children}
    </button>
  );
}

/**
 * Returns the app configuration for an env
 *
 */
function useAppConfig({ env }: { env: 'dev' | 'prod' | 'staging' }) {
  return useContext(AppContext);
}
````

### Comment tag handling

There is some special handling for specific JSDoc 'tags' (the @ things in comments), that
makes documentation a bit more convenient.

- `@type`: if the type tag is provided it is used **instead** of type information. This is
  useful for cases where the type annotation is hard to read or unclear.
- `@displayName`: The name you want to be displayed in documentation, if different from the inferred one.
- `@default`: For components this value is used as the default value for props

## Writing Examples

In addition to inline API documentation, Docpocalypse supports (and encourages) writing
longer form usage guides, complete with runnable, live editable examples. Examples are
[MDX](https://mdxjs.com/) files located in your doc site `/src/examples` folder.

To add an example file for a package feature create an `.mdx` file of the same name
in `./www/src/examples` directory. So if you have a `Button.tsx` component you'd
create a `Button.mdx` file in `examples`. Docpocalypse will automatically associate
files in the `examples` folder with features of the same name.

### Code blocks

MDX, like markdown supports "code blocks" (or "code fences"), to display properly
formatted and syntax highlighted code examples. Docpocalypse enhances example code blocks
by making the code in the blocks: **runnable** and **editable**, giving you live previews
as well as little playgrounds for users to explore features.

````markdown
This is a Code block ðŸ‘‡

```
Code blocks are written with 3 back ticks
```

They can be _interspersed_ with <strong>other</strong> MDX

You can also specify the language to get syntax highlighting

```js
const str = 'I am a JavaScript';
```

```css
.message {
  content: 'Works for CSS as well as other langauges';
  font-size: 120%;
}
```
````

Docpocalypse also can enhance code blocks, by turning them into runnable examples
that look like:

```jsx live
<>
  <strong>This!</strong>
  <p>You can edit the code ðŸ‘‡</p>
</>
```

In code blocks example files or MDX in JSDoc comments will automatically be turned
into editable examples when you add the `javascript`, `typescript`, `js`, `ts`, or `tsx`
language tag to your code block:

````md
```tsx ðŸ‘ˆ
<div>I'll be rendered and editable</div>
```
````

Under the hood Docpocalypse will render the last expression in the code block, in
the above case the `<div>`. If you need more control over when and how something
renders you can explictly call `render` like so:

````md
```tsx
setTimeout(() => {
  render(<div>I'll be render after a second</div>);
}, 1000);
```
````

If you want to opt out of this behavior add the `static` prop to your code block:

````md
```tsx static
<div>I'm just a code illustration</div>
```
````

> **Note**: you can also create editable examples in your MDX pages as well. However, in pages
> you need to explicitly opt-in by adding a `live` prop instead of of `static`

#### Importing modules

Sometimes it makes sense to use a dependency in your code block, or extract example setup to another
module. Docpocalypse supports importing code right in your editable code blocks.

- Imports are resolved relative to the file they are in, either the MDX file _or_ if defined
  in a code comment, relative to that file. Any webpack aliases or resolve logic will also be respected!
- Imports are resolved at compile time, and can't be changed in the live editor
- Imports are hidden by default to discourage runtime editing, but
  can be shown by adding the `showImports` prop to the code block.

This code block is importing the Docpocalypse `<Navbar>` component:

```js showImports live
import { Navbar } from '@docpocalypse/gatsby-theme';

<Navbar />;
```

#### Hooks and state

You can declare and render stateful React componenst in a code block as you might
expect. React, and the built-in hooks are already in scope:

```js live
function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const timer = setInterval(() => {
      setCount(c => c + 1);
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  return <div>Seconds elapsed: {count}</div>;
}

<Counter />;
```

This works, but is a bit boilerplate heavy, and that may detract from the goal of the example.
To avoid this, code blocks can specify `renderAsComponent` and Docpocalypse will
use the code as the body of a component:

```jsx live renderAsComponent
const [count, setCount] = useState(0);

useEffect(() => {
  const timer = setInterval(() => {
    setCount(c => c + 1);
  }, 1000);

  return () => clearInterval(timer);
}, []);

<div>Seconds elapsed: {count}</div>;
```
